<?php

namespace App\Services;

use App\Models\AutoReorderRule;
use App\Models\StockItem;
use App\Models\PurchaseOrder;
use App\Models\PurchaseOrderItem;
use App\Models\InventoryForecast;
use App\Models\Company;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Mail;

class AutoReorderService
{
    protected $forecastService;

    public function __construct(InventoryForecastService $forecastService)
    {
        $this->forecastService = $forecastService;
    }

    /**
     * Check all enabled reorder rules for a company
     */
    public function checkAllRules($companyId)
    {
        $rules = AutoReorderRule::where('company_id', $companyId)
            ->where('is_enabled', true)
            ->with(['stockItem', 'company'])
            ->get();

        $results = [
            'checked' => 0,
            'triggered' => 0,
            'orders_created' => 0,
            'errors' => [],
        ];

        foreach ($rules as $rule) {
            try {
                $rule->updateLastChecked();
                $results['checked']++;

                $triggered = $this->evaluateRule($rule);
                
                if ($triggered) {
                    $results['triggered']++;
                    $results['orders_created']++;
                }
            } catch (\Exception $e) {
                $results['errors'][] = [
                    'rule_id' => $rule->id,
                    'rule_name' => $rule->rule_name,
                    'error' => $e->getMessage(),
                ];
                Log::error('Auto reorder rule failed', [
                    'rule_id' => $rule->id,
                    'error' => $e->getMessage(),
                ]);
            }
        }

        return $results;
    }

    /**
     * Evaluate a single rule and trigger reorder if needed
     */
    public function evaluateRule(AutoReorderRule $rule)
    {
        // Get current stock level
        $stockItem = $rule->stockItem;
        $currentStock = $stockItem->current_quantity ?? 0;

        // Check if reorder is needed
        if (!$rule->shouldTriggerReorder($currentStock)) {
            return false;
        }

        // Get forecast if forecasting is enabled
        $forecast = null;
        if ($rule->use_forecasting) {
            $forecast = $this->getForecastForItem($rule->stock_item_id, $rule->company_id);
            
            // Generate forecast if it doesn't exist or is outdated
            if (!$forecast || $forecast->created_at->diffInDays(now()) > 7) {
                $forecast = $this->forecastService->generateForecast(
                    $stockItem,
                    $rule->forecast_horizon_days,
                    $rule->forecast_algorithm
                );
            }
        }

        // Calculate reorder quantity
        $reorderQuantity = $rule->getReorderQuantity($forecast);

        // Create purchase order
        $purchaseOrder = $this->createAutoPurchaseOrder($rule, $reorderQuantity);

        // Update rule tracking
        $rule->incrementTriggerCount();

        // Send notifications if enabled
        if ($rule->send_email_notification && $rule->notification_emails) {
            $this->sendReorderNotification($rule, $purchaseOrder);
        }

        return true;
    }

    /**
     * Create an automated purchase order
     */
    protected function createAutoPurchaseOrder(AutoReorderRule $rule, $quantity)
    {
        $stockItem = $rule->stockItem;
        $unitPrice = $rule->preferred_unit_price > 0 
            ? $rule->preferred_unit_price 
            : ($stockItem->unit_cost ?? 0);
        
        $totalAmount = $unitPrice * $quantity;

        // Determine approval status
        $autoApprove = $rule->shouldAutoApprove($totalAmount);
        
        $purchaseOrder = DB::transaction(function () use ($rule, $stockItem, $quantity, $unitPrice, $totalAmount, $autoApprove) {
            // Create purchase order
            $po = PurchaseOrder::create([
                'company_id' => $rule->company_id,
                'po_number' => $this->generatePONumber($rule->company_id),
                'supplier_name' => $rule->preferred_supplier_name ?? 'Auto-Generated',
                'supplier_email' => $rule->preferred_supplier_email,
                'supplier_phone' => $rule->preferred_supplier_phone,
                'supplier_address' => $rule->preferred_supplier_address,
                'order_date' => now(),
                'expected_delivery_date' => now()->addDays($rule->lead_time_days),
                'status' => $autoApprove ? 'approved' : 'pending',
                'total_amount' => $totalAmount,
                'notes' => "Auto-generated by rule: {$rule->rule_name}",
                'created_by_rule_id' => $rule->id,
                'auto_generated' => true,
            ]);

            // Create purchase order item
            PurchaseOrderItem::create([
                'purchase_order_id' => $po->id,
                'stock_item_id' => $rule->stock_item_id,
                'quantity' => $quantity,
                'unit_price' => $unitPrice,
                'total_price' => $totalAmount,
                'notes' => "Reorder point: {$rule->reorder_point}, Current stock: {$stockItem->current_quantity}",
            ]);

            return $po;
        });

        Log::info('Auto reorder triggered', [
            'rule_id' => $rule->id,
            'rule_name' => $rule->rule_name,
            'stock_item' => $stockItem->name,
            'quantity' => $quantity,
            'po_number' => $purchaseOrder->po_number,
            'auto_approved' => $autoApprove,
        ]);

        return $purchaseOrder;
    }

    /**
     * Generate unique PO number
     */
    protected function generatePONumber($companyId)
    {
        $prefix = 'AUTO-PO';
        $date = now()->format('Ymd');
        
        $lastPO = PurchaseOrder::where('company_id', $companyId)
            ->where('po_number', 'LIKE', "{$prefix}-{$date}%")
            ->orderBy('po_number', 'desc')
            ->first();

        if ($lastPO) {
            $lastNumber = (int) substr($lastPO->po_number, -4);
            $newNumber = str_pad($lastNumber + 1, 4, '0', STR_PAD_LEFT);
        } else {
            $newNumber = '0001';
        }

        return "{$prefix}-{$date}-{$newNumber}";
    }

    /**
     * Get the latest forecast for an item
     */
    protected function getForecastForItem($stockItemId, $companyId)
    {
        return InventoryForecast::where('stock_item_id', $stockItemId)
            ->where('company_id', $companyId)
            ->orderBy('created_at', 'desc')
            ->first();
    }

    /**
     * Send reorder notification emails
     */
    protected function sendReorderNotification(AutoReorderRule $rule, PurchaseOrder $purchaseOrder)
    {
        $emails = $rule->notification_emails;
        
        if (empty($emails)) {
            return;
        }

        try {
            $data = [
                'rule_name' => $rule->rule_name,
                'stock_item_name' => $rule->stockItem->name,
                'quantity' => $purchaseOrder->items->sum('quantity'),
                'po_number' => $purchaseOrder->po_number,
                'total_amount' => $purchaseOrder->total_amount,
                'status' => $purchaseOrder->status,
                'expected_delivery' => $purchaseOrder->expected_delivery_date,
                'supplier' => $purchaseOrder->supplier_name,
            ];

            foreach ($emails as $email) {
                Mail::send('emails.auto-reorder-notification', $data, function ($message) use ($email, $rule) {
                    $message->to($email)
                        ->subject("Auto Reorder Triggered: {$rule->rule_name}");
                });
            }

            Log::info('Reorder notification sent', [
                'rule_id' => $rule->id,
                'po_number' => $purchaseOrder->po_number,
                'recipients' => $emails,
            ]);
        } catch (\Exception $e) {
            Log::error('Failed to send reorder notification', [
                'rule_id' => $rule->id,
                'error' => $e->getMessage(),
            ]);
        }
    }

    /**
     * Calculate Economic Order Quantity using historical data
     */
    public function calculateEOQWithHistory(AutoReorderRule $rule, $daysOfHistory = 90)
    {
        $stockItem = $rule->stockItem;
        
        // Get historical demand
        $historicalDemand = $this->getHistoricalDemand($rule->stock_item_id, $daysOfHistory);
        
        if (empty($historicalDemand)) {
            return $rule->reorder_quantity;
        }

        // Calculate average daily demand
        $totalDemand = array_sum($historicalDemand);
        $avgDailyDemand = $totalDemand / count($historicalDemand);
        $annualDemand = $avgDailyDemand * 365;

        // EOQ formula: âˆš(2DS/H)
        $orderingCost = $rule->ordering_cost;
        $holdingCost = $rule->preferred_unit_price * ($rule->holding_cost_percentage / 100);

        if ($orderingCost <= 0 || $holdingCost <= 0) {
            return $rule->reorder_quantity;
        }

        $eoq = sqrt((2 * $annualDemand * $orderingCost) / $holdingCost);

        return round($eoq);
    }

    /**
     * Get historical demand data
     */
    protected function getHistoricalDemand($stockItemId, $days)
    {
        // This would typically query stock movement history
        // For now, return empty array as placeholder
        // TODO: Implement based on your stock movement tracking
        return [];
    }

    /**
     * Check if a rule should run based on its schedule
     */
    public function shouldRunRule(AutoReorderRule $rule)
    {
        if (!$rule->is_enabled) {
            return false;
        }

        $now = now();
        $lastChecked = $rule->last_checked_at;

        // If never checked, run it
        if (!$lastChecked) {
            return true;
        }

        // Check frequency
        switch ($rule->check_frequency) {
            case 'hourly':
                return $lastChecked->diffInHours($now) >= 1;
                
            case 'daily':
                // Check if it's past the scheduled time and hasn't run today
                $scheduledTime = \Carbon\Carbon::parse($rule->check_time);
                return !$lastChecked->isToday() || 
                       ($now->format('H:i') >= $scheduledTime->format('H:i') && !$lastChecked->isToday());
                
            case 'weekly':
                // Check if it's the right day and hasn't run this week
                $dayOfWeek = strtolower($now->format('l'));
                $checkDays = $rule->check_days ?? [];
                
                return in_array($dayOfWeek, $checkDays) && 
                       $lastChecked->diffInDays($now) >= 7;
                
            default:
                return false;
        }
    }
}
